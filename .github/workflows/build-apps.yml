name: build-apps

on:
  workflow_call:
    inputs:
      applications:
        required: true
        type: string
      runner:
        required: true
        type: string

env:
  GH_REGISTRY: ${{ secrets.GH_REGISTRY }}
  DOCKERHUB_ORG: ${{ secrets.DOCKERHUB_ORG }}
  OS_PASSWORD: ${{ secrets.SWIFT_OS_PASSWORD }}
  OS_PROJECT_ID: ${{ secrets.SWIFT_OS_PROJECT_ID }}
  OS_USERNAME: ${{ secrets.SWIFT_OS_USERNAME }}
  OS_APPLICATION_CREDENTIAL_ID: ${{ secrets.SWIFT_OS_APPLICATION_CREDENTIAL_ID }}
  OS_APPLICATION_CREDENTIAL_SECRET: ${{ secrets.SWIFT_OS_APPLICATION_CREDENTIAL_SECRET }}

jobs:
  build:
    if: ${{ inputs.applications != '[]' }}
    runs-on: ${{ fromJSON(inputs.runner) }}
    strategy:
      fail-fast: false
      matrix:
        application: ${{ fromJSON(inputs.applications) }}
    permissions:
      packages: write
      id-token: write
      contents: write
    outputs:
      BUILDDATE: ${{ steps.ENVVARS.outputs.BUILDDATE }}
      IMAGENAME: ${{ steps.IMAGEVARS.outputs.IMAGENAME }}
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683
        with:
          token: ${{ secrets.NEURODESK_GITHUB_TOKEN_ISSUE_AUTOMATION || secrets.GITHUB_TOKEN }}
      - name: Set environment variables
        id: ENVVARS
        run: |
          APPLICATION=${{ matrix.application }}
          SHORT_SHA=$(git rev-parse --short $GITHUB_SHA)
          BUILDDATE=`date +%Y%m%d`
          echo "APPLICATION=$APPLICATION" >> $GITHUB_ENV
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_ENV
          echo "BUILDDATE=$BUILDDATE" >> $GITHUB_OUTPUT
      - name: Fetch build config overrides
        if: "!contains(inputs.runner, 'self-hosted')"
        run: |
          FREEUPSPACE=$(cat .github/workflows/build-config.json | jq -r ".${APPLICATION}.freeUpSpace // .default.freeUpSpace // false")
          echo "FREEUPSPACE=${FREEUPSPACE}"
          echo "FREEUPSPACE=${FREEUPSPACE}" >> $GITHUB_ENV
      - name: Free up space (optional)
        if: env.FREEUPSPACE == 'true'
        uses: easimon/maximize-build-space@fc881a613ad2a34aca9c9624518214ebc21dfc0c
        with:
          root-reserve-mb: 40000
          swap-size-mb: 1024
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          overprovision-lvm: "true"
      - name: Move docker installation (optional)
        if: env.FREEUPSPACE == 'true'
        run: |
          sudo mv /var/lib/docker /home/runner/work/docker
          sudo ln -s /home/runner/work/docker /var/lib/docker
          sudo systemctl restart docker
      - name: Install Builder Dependencies
        run: |
          pip install -r requirements.txt
      - name: Generate Dockerfile and Release File
        id: generate
        run: |
          echo "APPLICATION: $APPLICATION"
          ./builder/build.py generate $APPLICATION --recreate --auto-build --generate-release
      - name: Set image variables
        id: IMAGEVARS
        run: |
          DOCKERFILE=`basename $(find ./build/$APPLICATION/ -type f -iname "*.Dockerfile" | head -1)`
          # if the dockerfile is not found, exit with error
          if [ -z "$DOCKERFILE" ]; then
            echo "Dockerfile not found for $APPLICATION"
            exit 1
          fi
          IMAGENAME=$(echo $(basename $DOCKERFILE .Dockerfile) | tr '[A-Z]' '[a-z]')
          IMAGEID=ghcr.io/$GITHUB_REPOSITORY/$IMAGENAME
          IMAGEID=$(echo $IMAGEID | tr '[A-Z]' '[a-z]')  
          echo "IMAGENAME: $IMAGENAME"
          echo "IMAGENAME_TEST=${IMAGENAME//_/ }" >> $GITHUB_ENV
          echo "test command: bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } $BUILDDATE"
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_ENV
          echo "IMAGENAME=$IMAGENAME" >> $GITHUB_OUTPUT
          echo "IMAGEID=$IMAGEID" >> $GITHUB_ENV

      - name: Login to GHCR
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435

      - name: Get rootfs of cached image
        run: |
          docker pull $IMAGEID:latest && ROOTFS_CACHE=$(docker inspect --format='{{.RootFS}}' $IMAGEID:latest) && docker rmi $IMAGEID:latest || true
          echo "ROOTFS_CACHE=$ROOTFS_CACHE" >> $GITHUB_ENV

      - name: Build and export
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83
        with:
          context: .
          file: ./build/${{ env.APPLICATION }}/${{ env.IMAGENAME }}.Dockerfile
          load: true
          tags: ${{ env.IMAGEID }}:${{ env.BUILDDATE }}
          cache-from: type=registry,ref=${{ env.IMAGEID }}:latest
          cache-to: type=inline
          outputs: type=docker,dest=${{ runner.temp }}/${{ env.IMAGENAME }}-${{ env.BUILDDATE }}.tar

      - name: Upload artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: ${{ env.IMAGENAME }}-${{ env.BUILDDATE }}
          path: ${{ runner.temp }}/${{ env.IMAGENAME }}-${{ env.BUILDDATE }}.tar

      # - name: Log into Github Package registry
      #   if: "${{ env.GH_REGISTRY != '' }}"
      #   run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin
      # - name: Log into Dockerhub (optional)
      #   if: "${{ env.DOCKERHUB_ORG != '' }}"
      #   run: echo "${{ secrets.DOCKERHUB_PASSWORD }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
      # - name: Run docker builder and build singularity/apptainer image
      #   run: /bin/bash .github/workflows/build-docker-and-simg.sh $IMAGENAME
      # - name: Upload nectar object storage
      #   run: /bin/bash .github/workflows/upload-nectar.sh $IMAGENAME
      # - name: Configure aws credentials
      #   uses: aws-actions/configure-aws-credentials@ececac1a45f3b08a01d2dd070d28d111c5fe6722
      #     role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
      #     aws-region: us-east-2
      # - name: Upload to AWS S3
      #   run: /bin/bash .github/workflows/upload-aws-s3.sh $IMAGENAME
      # - name: Create Release File Pull Request
      #   if: steps.generate.outputs.container_name
      #   env:
      #     GH_TOKEN: ${{ secrets.NEURODESK_GITHUB_TOKEN_ISSUE_AUTOMATION || secrets.GITHUB_TOKEN }}
      #     CONTAINER_NAME: ${{ steps.generate.outputs.container_name }}
      #     CONTAINER_VERSION: ${{ steps.generate.outputs.container_version }}
      #     RELEASE_CONTENT: ${{ steps.generate.outputs.release_file_content }}
      #   run: |
      #     gh auth setup-git

      #     # Configure git
      #     git config --global user.name "neurocontainers-bot"
      #     git config --global user.email "neurocontainers-bot@neurodesk.github.io"

      #     # Create a new branch for the release
      #     BRANCH_NAME="release/${CONTAINER_NAME}-${CONTAINER_VERSION}-$(date +%Y%m%d-%H%M%S)"
      #     git checkout -b "$BRANCH_NAME"

      #     # Create the release file
      #     RELEASE_DIR="releases/${CONTAINER_NAME}"
      #     RELEASE_FILE="${RELEASE_DIR}/${CONTAINER_VERSION}.json"

      #     mkdir -p "$RELEASE_DIR"
      #     echo "$RELEASE_CONTENT" > "$RELEASE_FILE"

      #     # Check if this is a new file or an update
      #     if git ls-files --error-unmatch "$RELEASE_FILE" 2>/dev/null; then
      #       ACTION="Update"
      #     else
      #       ACTION="Add"
      #     fi

      #     # Add and commit the release file
      #     git add "$RELEASE_FILE"
      #     git commit -m "${ACTION} release file for ${CONTAINER_NAME} ${CONTAINER_VERSION}

      #     Auto-generated release file from container build.

      #     ðŸ¤– Generated by neurocontainers CI"

      #     # Push the branch
      #     git push origin "$BRANCH_NAME"

      #     # Create pull request
      #     gh pr create \
      #       --title "${ACTION} release for ${CONTAINER_NAME} ${CONTAINER_VERSION}" \
      #       --body "## Summary

      #     This PR ${ACTION,,}s the release file for **${CONTAINER_NAME} ${CONTAINER_VERSION}**.

      #     ## Changes

      #     - ${ACTION} \`${RELEASE_FILE}\` with container metadata
      #     - Generated automatically from successful container build
      #     - Contains categories and GUI applications from build.yaml

      #     ## Testing Instructions

      #     To test this container on Neurodesk (either a local installation or https://play.neurodesk.org/):
      #     \`\`\`bash
      #     bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } ${BUILDDATE}
      #     \`\`\`

      #     Or, for testing directly with Apptainer/Singularity:
      #     \`\`\`bash
      #     curl -X GET https://neurocontainers.neurodesk.org/temporary-builds-new/${IMAGENAME}_${BUILDDATE}.simg -O
      #     singularity shell --overlay /tmp/apptainer_overlay ${IMAGENAME}_${BUILDDATE}.simg
      #     \`\`\`

      #     ## Review Checklist

      #     - [ ] Release file format is correct
      #     - [ ] Categories are appropriate for this container
      #     - [ ] GUI applications (if any) are correctly defined
      #     - [ ] Version and build date are accurate
      #     - [ ] Container has been tested using the commands above

      #     ## Next Steps

      #     After merging this PR:
      #     1. The apps.json update workflow will automatically regenerate apps.json from all release files
      #     2. A PR will be created to the neurocommand repository
      #     3. The container will become available in neurodesk

      #     If additional releases are needed:
      #     - Add to apps.json to release to Neurodesk: https://github.com/NeuroDesk/neurocommand/edit/main/neurodesk/apps.json
      #     - Or add to the Open Recon recipes: https://github.com/NeuroDesk/openrecon/tree/main/recipes

      #     ðŸ¤– Generated by neurocontainers CI | Created by @${GITHUB_ACTOR}" \
      #       --head "$BRANCH_NAME" \
      #       --base main \
      #       --label "automated" \
      #       --label "release"

      #     echo "âœ… Pull request created for ${CONTAINER_NAME} ${CONTAINER_VERSION}"
      # - name: Generate job output
      #   run: |
      #     echo "The container has been successfully build. To test the container, run this:" >> $GITHUB_STEP_SUMMARY
      #     echo "" >> $GITHUB_STEP_SUMMARY # this is a blank line
      #     echo "bash /neurocommand/local/fetch_and_run.sh ${IMAGENAME//_/ } $BUILDDATE" >> $GITHUB_STEP_SUMMARY
      # # - name: Check image for wasted space using dive DOESN'T WORK AT THE MOMENT
      # #   uses: MartinHeinz/dive-action@d76c172050c82c60a3742ab5487c2d3ac8b3306f
      # #   if: ${{ !contains(github.event.head_commit.message, 'skipdive') && github.ref == 'refs/heads/main'}}
      # #   with:
      # #     image: vnmd/${{ env.IMAGENAME }}:${{ env.BUILDDATE }}
      # #     config: ${{ github.workspace }}/.github/.dive-ci.yml